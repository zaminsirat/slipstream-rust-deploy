name: Build and Release

on:
  workflow_dispatch:
  release:
    types: [published]

jobs:
  build:
    permissions:
      contents: write
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            asset_name: linux-amd64
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            asset_name: windows-amd64
          - os: macos-latest
            target: aarch64-apple-darwin
            asset_name: darwin-arm64
      fail-fast: false

    runs-on: ${{ matrix.os }}
    env:
      TARGET: ${{ matrix.target }}
      ASSET_NAME: ${{ matrix.asset_name }}
      EXE_EXT: ${{ contains(matrix.target, 'windows') && '.exe' || '' }}

    steps:
      - name: Checkout slipstream-rust-deploy repository (for patches)
        uses: actions/checkout@v4
        with:
          path: .
      
      - name: Checkout slipstream-rust repository
        uses: actions/checkout@v4
        with:
          repository: Mygod/slipstream-rust
          ref: main
          submodules: recursive
          path: slipstream-rust

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}


      - name: Install cross toolchain (linker + libs)
        uses: taiki-e/setup-cross-toolchain-action@v1
        with:
          target: ${{ env.TARGET }}
            
      - name: Get slipstream-rust commit hash
        id: get_commit
        working-directory: slipstream-rust
        shell: bash
        run: echo "commit=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT

      - name: Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            slipstream-rust/target/
          key: ${{ runner.os }}-rust-${{ matrix.target }}-${{ steps.get_commit.outputs.commit }}
          restore-keys: |
            ${{ runner.os }}-rust-${{ matrix.target }}-
            ${{ runner.os }}-rust-

      - name: Install build dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          if [[ "${{ matrix.target }}" == "aarch64-unknown-linux-gnu" ]]; then
            sudo sed -i '/^Architectures:/d' /etc/apt/sources.list.d/ubuntu.sources
            sudo sed -i '/Signed-By:/a Architectures: amd64' /etc/apt/sources.list.d/ubuntu.sources

            sudo tee /etc/apt/sources.list.d/arm64-ports.sources > /dev/null << 'EOFARM64'
          Types: deb
          URIs: http://ports.ubuntu.com/ubuntu-ports
          Suites: noble noble-updates noble-backports
          Components: main restricted universe multiverse
          Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg
          Architectures: arm64

          Types: deb
          URIs: http://ports.ubuntu.com/ubuntu-ports
          Suites: noble-security
          Components: main restricted universe multiverse
          Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg
          Architectures: arm64
          EOFARM64

            sudo dpkg --add-architecture arm64
          fi
          sudo apt-get update
          sudo apt-get install -y cmake pkg-config libssl-dev gcc g++ \
            qemu-user-static binfmt-support perl \
            gcc-aarch64-linux-gnu g++-aarch64-linux-gnu \
            gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf musl-tools

      # - name: Install ARM64 OpenSSL for cross-compilation (Linux)
      #   if: runner.os == 'Linux' && matrix.target == 'aarch64-unknown-linux-gnu'
      #   run: |
      #     wget http://ports.ubuntu.com/pool/main/o/openssl/openssl_1.1.1f-1ubuntu2_arm64.deb
      #     wget http://ports.ubuntu.com/pool/main/o/openssl/libssl-dev_1.1.1f-1ubuntu2_arm64.deb
      #     wget http://ports.ubuntu.com/pool/main/o/openssl/libssl1.1_1.1.1f-1ubuntu2_arm64.deb
          
      #     sudo dpkg -i libssl1.1_1.1.1f-1ubuntu2_arm64.deb
      #     sudo dpkg -i libssl-dev_1.1.1f-1ubuntu2_arm64.deb
      #     sudo dpkg -i openssl_1.1.1f-1ubuntu2_arm64.deb

      - name: Install build dependencies (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install cmake pkg-config
          # For x86_64 cross-compilation, we need x86_64 OpenSSL
          if [[ "${{ matrix.target }}" == "x86_64-apple-darwin" ]]; then
            # Install x86_64 Homebrew and OpenSSL
            arch -x86_64 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" || true
            arch -x86_64 /usr/local/bin/brew install openssl@3
          else
            brew install openssl@3
          fi

      - name: Install build dependencies (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          choco install cmake openssl pkgconfiglite strawberryperl -y
          
          # Find and configure OpenSSL
          $opensslPaths = @(
            "C:\Program Files\OpenSSL",
            "C:\Program Files\OpenSSL-Win64",
            "C:\OpenSSL-Win64",
            "C:\OpenSSL"
          )
          
          foreach ($path in $opensslPaths) {
            if (Test-Path $path) {
              $libDir = Get-ChildItem -Path "$path\lib" -Filter "libcrypto*.lib" -Recurse -ErrorAction SilentlyContinue |
                        Select-Object -First 1 | ForEach-Object { $_.DirectoryName }
              
              if ($libDir) {
                echo "OPENSSL_DIR=$path" >> $env:GITHUB_ENV
                echo "OPENSSL_LIB_DIR=$libDir" >> $env:GITHUB_ENV
                echo "OPENSSL_INCLUDE_DIR=$path\include" >> $env:GITHUB_ENV
                Write-Host "OpenSSL configured at $path (libs in $libDir)"
                break
              }
            }
          }

      - name: Setup OpenSSL (macOS)
        if: runner.os == 'macOS'
        run: |
          if [[ "${{ matrix.target }}" == "x86_64-apple-darwin" ]]; then
            # Use x86_64 OpenSSL from /usr/local (Intel Homebrew prefix)
            echo "PKG_CONFIG_PATH=/usr/local/opt/openssl@3/lib/pkgconfig:$PKG_CONFIG_PATH" >> $GITHUB_ENV
            echo "OPENSSL_DIR=/usr/local/opt/openssl@3" >> $GITHUB_ENV
            echo "OPENSSL_ROOT_DIR=/usr/local/opt/openssl@3" >> $GITHUB_ENV
          else
            # Use ARM64 OpenSSL from /opt/homebrew
            echo "PKG_CONFIG_PATH=/opt/homebrew/opt/openssl@3/lib/pkgconfig:$PKG_CONFIG_PATH" >> $GITHUB_ENV
            echo "OPENSSL_DIR=/opt/homebrew/opt/openssl@3" >> $GITHUB_ENV
            echo "OPENSSL_ROOT_DIR=/opt/homebrew/opt/openssl@3" >> $GITHUB_ENV
          fi

      - name: Setup cross-compilation (Linux ARM)
        if: runner.os == 'Linux' && (matrix.target == 'aarch64-unknown-linux-gnu' || matrix.target == 'armv7-unknown-linux-gnueabihf')
        run: |
          echo "PKG_CONFIG_ALLOW_CROSS=1" >> $GITHUB_ENV
          echo "OPENSSL_STATIC=1" >> $GITHUB_ENV
          
          if [[ "${{ matrix.target }}" == "aarch64-unknown-linux-gnu" ]]; then
            TRIPLET="aarch64-linux-gnu"
            echo "CC_aarch64_unknown_linux_gnu=${TRIPLET}-gcc" >> $GITHUB_ENV
            echo "CXX_aarch64_unknown_linux_gnu=${TRIPLET}-g++" >> $GITHUB_ENV
            echo "AR_aarch64_unknown_linux_gnu=${TRIPLET}-ar" >> $GITHUB_ENV
            echo "CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=${TRIPLET}-gcc" >> $GITHUB_ENV
          else
            TRIPLET="arm-linux-gnueabihf"
            echo "CC_armv7_unknown_linux_gnueabihf=${TRIPLET}-gcc" >> $GITHUB_ENV
            echo "CXX_armv7_unknown_linux_gnueabihf=${TRIPLET}-g++" >> $GITHUB_ENV
            echo "AR_armv7_unknown_linux_gnueabihf=${TRIPLET}-ar" >> $GITHUB_ENV
            echo "CARGO_TARGET_ARMV7_UNKNOWN_LINUX_GNUEABIHF_LINKER=${TRIPLET}-gcc" >> $GITHUB_ENV
          fi
          
          echo "CC=${TRIPLET}-gcc" >> $GITHUB_ENV
          echo "CXX=${TRIPLET}-g++" >> $GITHUB_ENV
          echo "AR=${TRIPLET}-ar" >> $GITHUB_ENV

      - name: Build picoquic (Linux native)
        if: runner.os == 'Linux' && matrix.target == 'x86_64-unknown-linux-gnu'
        working-directory: slipstream-rust
        run: |
          bash scripts/build_picoquic.sh
          echo "PICOQUIC_DIR=${GITHUB_WORKSPACE}/slipstream-rust/vendor/picoquic" >> $GITHUB_ENV
          echo "PICOQUIC_BUILD_DIR=${GITHUB_WORKSPACE}/slipstream-rust/.picoquic-build" >> $GITHUB_ENV

      - name: Build picoquic (macOS)
        if: runner.os == 'macOS'
        working-directory: slipstream-rust
        shell: bash
        run: |
          PICOQUIC_DIR="${GITHUB_WORKSPACE}/slipstream-rust/vendor/picoquic"
          PICOQUIC_BUILD_DIR="${GITHUB_WORKSPACE}/slipstream-rust/.picoquic-build"
          
          CMAKE_ARGS=(-S "$PICOQUIC_DIR" -B "$PICOQUIC_BUILD_DIR"
            -DCMAKE_BUILD_TYPE=Release
            -DPICOQUIC_FETCH_PTLS=ON
            -Wno-dev)
          
          if [[ "${{ matrix.target }}" == "x86_64-apple-darwin" ]]; then
            CMAKE_ARGS+=(-DCMAKE_OSX_ARCHITECTURES=x86_64)
            # Use x86_64 OpenSSL for cross-compilation
            CMAKE_ARGS+=(-DOPENSSL_ROOT_DIR=/usr/local/opt/openssl@3)
            CMAKE_ARGS+=(-DOPENSSL_INCLUDE_DIR=/usr/local/opt/openssl@3/include)
            CMAKE_ARGS+=(-DOPENSSL_CRYPTO_LIBRARY=/usr/local/opt/openssl@3/lib/libcrypto.dylib)
            CMAKE_ARGS+=(-DOPENSSL_SSL_LIBRARY=/usr/local/opt/openssl@3/lib/libssl.dylib)
            # Set C compiler flags to target x86_64
            CMAKE_ARGS+=(-DCMAKE_C_FLAGS="-arch x86_64")
            CMAKE_ARGS+=(-DCMAKE_CXX_FLAGS="-arch x86_64")
          fi
          
          # Initial configure to fetch picotls
          cmake "${CMAKE_ARGS[@]}" || true
          
          # Patch picotls CMake version requirement
          PTLS_CMAKE="$PICOQUIC_BUILD_DIR/_deps/picotls-src/CMakeLists.txt"
          if [ -f "$PTLS_CMAKE" ]; then
            sed -i '' 's/CMAKE_MINIMUM_REQUIRED(VERSION [0-9.]*)/CMAKE_MINIMUM_REQUIRED(VERSION 3.15)/' "$PTLS_CMAKE" || true
          fi
          
          # Reconfigure and build
          cmake "${CMAKE_ARGS[@]}"
          cmake --build "$PICOQUIC_BUILD_DIR"
          
          # Create dummy fusion library for ARM (no AES-NI)
          PTLS_BUILD_DIR="$PICOQUIC_BUILD_DIR/_deps/picotls-build"
          if [ ! -f "$PTLS_BUILD_DIR/libpicotls-fusion.a" ]; then
            if [[ "${{ matrix.target }}" == "x86_64-apple-darwin" ]]; then
              echo 'void picotls_fusion_placeholder(void) {}' | cc -arch x86_64 -c -x c - -o /tmp/dummy.o
            else
              echo 'void picotls_fusion_placeholder(void) {}' | cc -c -x c - -o /tmp/dummy.o
            fi
            ar rcs "$PTLS_BUILD_DIR/libpicotls-fusion.a" /tmp/dummy.o
          fi
          
          echo "PICOQUIC_DIR=$PICOQUIC_DIR" >> $GITHUB_ENV
          echo "PICOQUIC_BUILD_DIR=$PICOQUIC_BUILD_DIR" >> $GITHUB_ENV

      - name: Build picoquic (Windows)
        if: runner.os == 'Windows'
        working-directory: slipstream-rust
        shell: bash
        run: |
          PICOQUIC_DIR="${GITHUB_WORKSPACE}/slipstream-rust/vendor/picoquic"
          PICOQUIC_BUILD_DIR="${GITHUB_WORKSPACE}/slipstream-rust/.picoquic-build"
          
          # Convert OpenSSL path
          OPENSSL_PATH=$(echo "${OPENSSL_DIR:-}" | sed 's|\\|/|g')
          
          # Find OpenSSL libraries
          CRYPTO_LIB=$(find "$OPENSSL_PATH/lib" -name "libcrypto*.lib" 2>/dev/null | head -1)
          SSL_LIB=$(find "$OPENSSL_PATH/lib" -name "libssl*.lib" 2>/dev/null | head -1)
          WINCOMPAT_H="${PICOQUIC_DIR}/picoquic/wincompat.h"
          CMAKE_ARGS=(-S "$PICOQUIC_DIR" -B "$PICOQUIC_BUILD_DIR"
            -G "Visual Studio 17 2022" -A x64
            -DCMAKE_BUILD_TYPE=Release
            -DCMAKE_POLICY_VERSION_MINIMUM=3.5
            -DPICOQUIC_FETCH_PTLS=ON
            -DBUILD_TESTING=OFF
            -DCMAKE_C_FLAGS="/D_WINDOWS /FI\"${WINCOMPAT_H}\" /FI\"ws2tcpip.h\"" \
            -DCMAKE_CXX_FLAGS="/D_WINDOWS /FI\"${WINCOMPAT_H}\" /FI\"ws2tcpip.h\"" \
            -Dpicoquic_BUILD_TESTS=OFF
            -Wno-dev)
          
          if [ -n "$CRYPTO_LIB" ] && [ -n "$SSL_LIB" ]; then
            CMAKE_ARGS+=(
              -DOPENSSL_ROOT_DIR="$OPENSSL_PATH"
              -DOPENSSL_CRYPTO_LIBRARY="$CRYPTO_LIB"
              -DOPENSSL_SSL_LIBRARY="$SSL_LIB"
              -DOPENSSL_INCLUDE_DIR="$OPENSSL_PATH/include")
          fi
          
          # Initial configure to fetch picotls
          cmake "${CMAKE_ARGS[@]}" || true
          
          # Patch picotls CMake version requirement
          PTLS_CMAKE="$PICOQUIC_BUILD_DIR/_deps/picotls-src/CMakeLists.txt"
          PTLS_SRC="$PICOQUIC_BUILD_DIR/_deps/picotls-src"
          if [ -f "$PTLS_CMAKE" ]; then
            sed -i 's/CMAKE_MINIMUM_REQUIRED(VERSION [0-9.]*)/CMAKE_MINIMUM_REQUIRED(VERSION 3.15)/' "$PTLS_CMAKE" || true
          fi
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            WINCOMPAT_FILE=""
            for dir in "wincompat" "win" "picotlsvs/picotls"; do
              if [ -f "$PTLS_SRC/$dir/wincompat.h" ]; then
                WINCOMPAT_FILE="$PTLS_SRC/$dir/wincompat.h"
                break
              fi
            done
        
            if [ -z "$WINCOMPAT_FILE" ]; then
              WINCOMPAT_FILE=$(find "$PTLS_SRC" -name "wincompat.h" 2>/dev/null | head -1)
            fi
        
            if [ -n "$WINCOMPAT_FILE" ] && [ -f "$WINCOMPAT_FILE" ]; then
              cp "$WINCOMPAT_FILE" "$PTLS_SRC/include/" 2>/dev/null || true
              cp "$WINCOMPAT_FILE" "$PTLS_SRC/lib/" 2>/dev/null || true
            fi
            
            # Copy wincompat.c (wintimeofday implementation) to picotls lib directory
            WINCOMPAT_C_SRC="${GITHUB_WORKSPACE}/patches/wincompat.c"
            if [ -f "$WINCOMPAT_C_SRC" ]; then
              cp "$WINCOMPAT_C_SRC" "$PTLS_SRC/lib/wincompat.c"
              echo "Copied wincompat.c to picotls lib directory"
              
              # Patch picotls CMakeLists.txt to include wincompat.c in picotls-core
              PTLS_CMAKE="$PTLS_SRC/CMakeLists.txt"
              if [ -f "$PTLS_CMAKE" ]; then
                # Append target_sources to add wincompat.c to picotls-core on Windows
                echo "" >> "$PTLS_CMAKE"
                echo "# Windows compatibility: add wintimeofday implementation" >> "$PTLS_CMAKE"
                echo "if(WIN32)" >> "$PTLS_CMAKE"
                echo "  target_sources(picotls-core PRIVATE lib/wincompat.c)" >> "$PTLS_CMAKE"
                echo "endif()" >> "$PTLS_CMAKE"
                echo "Patched picotls CMakeLists.txt to include wincompat.c"
              fi
            fi
          fi

          
          # Patch picoquic header for Windows function signature compatibility
          PICOQUIC_HEADER="${PICOQUIC_DIR}/picoquic/picoquic_packet_loop.h"
          if [ -f "$PICOQUIC_HEADER" ]; then
            awk 'BEGIN {found=0} /^void\* picoquic_packet_loop_v3\(void\* v_ctx\);$/ {print "#ifdef _WINDOWS"; print "DWORD WINAPI picoquic_packet_loop_v3(LPVOID v_ctx);"; print "#else"; print "void* picoquic_packet_loop_v3(void* v_ctx);"; print "#endif"; found=1; next} {print}' "$PICOQUIC_HEADER" > "${PICOQUIC_HEADER}.tmp" && mv "${PICOQUIC_HEADER}.tmp" "$PICOQUIC_HEADER" || {
              echo "Warning: Failed to patch picoquic_packet_loop.h, trying alternative method..."
              perl -i -pe 's/^void\* picoquic_packet_loop_v3\(void\* v_ctx\);$/#ifdef _WINDOWS\nDWORD WINAPI picoquic_packet_loop_v3(LPVOID v_ctx);\n#else\nvoid* picoquic_packet_loop_v3(void* v_ctx);\n#endif/' "$PICOQUIC_HEADER" 2>/dev/null || echo "Warning: Could not patch header file"
            }
          fi
          
          # Reconfigure and build
          cmake "${CMAKE_ARGS[@]}"
          cmake --build "$PICOQUIC_BUILD_DIR" --config Release \
            --target picoquic-core picotls-core picotls-fusion picotls-minicrypto picotls-openssl
          
          # Create .a symlinks for build.rs (expects Unix library names)
          RELEASE_DIR="$PICOQUIC_BUILD_DIR/Release"
          PTLS_RELEASE="${PICOQUIC_BUILD_DIR}/_deps/picotls-build/Release"
          
          for lib in picoquic-core picotls-core picotls-fusion picotls-minicrypto picotls-openssl; do
            src_dir="$RELEASE_DIR"
            [ "$lib" != "picoquic-core" ] && src_dir="$PTLS_RELEASE"
            
            if [ -f "$src_dir/${lib}.lib" ]; then
              cp "$src_dir/${lib}.lib" "$RELEASE_DIR/lib${lib}.a"
              cp "$src_dir/${lib}.lib" "$RELEASE_DIR/lib${lib//-/_}.a"
            fi
          done
          
          echo "PICOQUIC_DIR=$PICOQUIC_DIR" >> $GITHUB_ENV
          echo "PICOQUIC_BUILD_DIR=$PICOQUIC_BUILD_DIR" >> $GITHUB_ENV
          echo "PICOQUIC_LIB_DIR=$RELEASE_DIR" >> $GITHUB_ENV

      - name: Setup ARM cross-compilation (skip picoquic pre-build)
        if: runner.os == 'Linux' && (matrix.target == 'aarch64-unknown-linux-gnu' || matrix.target == 'armv7-unknown-linux-gnueabihf')
        run: |
          echo "PICOQUIC_DIR=${GITHUB_WORKSPACE}/slipstream-rust/vendor/picoquic" >> $GITHUB_ENV
          echo "PICOQUIC_FETCH_PTLS=ON" >> $GITHUB_ENV
          echo "PICOQUIC_AUTO_BUILD=1" >> $GITHUB_ENV

      - name: Patch macOS sockaddr compatibility
        if: runner.os == 'macOS'
        working-directory: slipstream-rust
        run: |
          # Patch runtime.rs
          RUNTIME_RS="crates/slipstream-ffi/src/runtime.rs"
          if [ -f "$RUNTIME_RS" ] && ! grep -q "sin_len:" "$RUNTIME_RS"; then
            perl -i -pe 's/(let sockaddr = libc::sockaddr_in \{)/$1\n                sin_len: std::mem::size_of::<libc::sockaddr_in>() as u8,/' "$RUNTIME_RS"
            perl -i -pe 's/(let sockaddr = libc::sockaddr_in6 \{)/$1\n                sin6_len: std::mem::size_of::<libc::sockaddr_in6>() as u8,/' "$RUNTIME_RS"
          fi
          
          # Patch server.rs
          SERVER_RS="crates/slipstream-server/src/server.rs"
          if [ -f "$SERVER_RS" ] && ! grep -q "sin6_len:" "$SERVER_RS"; then
            perl -i -pe 's/(let sockaddr = libc::sockaddr_in \{)/$1\n                sin_len: std::mem::size_of::<libc::sockaddr_in>() as u8,/' "$SERVER_RS"
            perl -i -pe 's/(let sockaddr = libc::sockaddr_in6 \{)/$1\n                sin6_len: std::mem::size_of::<libc::sockaddr_in6>() as u8,/' "$SERVER_RS"
          fi
          
          # Patch udp_fallback.rs
          UDP_FALLBACK_RS="crates/slipstream-server/src/udp_fallback.rs"
          if [ -f "$UDP_FALLBACK_RS" ] && ! grep -q "sin6_len:" "$UDP_FALLBACK_RS"; then
            perl -i -pe 's/(let sockaddr = libc::sockaddr_in \{)/$1\n        sin_len: std::mem::size_of::<libc::sockaddr_in>() as u8,/' "$UDP_FALLBACK_RS"
            perl -i -pe 's/(let sockaddr = libc::sockaddr_in6 \{)/$1\n        sin6_len: std::mem::size_of::<libc::sockaddr_in6>() as u8,/' "$UDP_FALLBACK_RS"
          fi

      - name: Patch picoquic headers for Windows (arpa/inet.h -> winsock2.h)
        if: runner.os == 'Windows'
        working-directory: slipstream-rust
        shell: bash
        run: |
          PICOQUIC_DIR="${GITHUB_WORKSPACE}/slipstream-rust/vendor/picoquic"
          
          # Patch picoquic.h to handle MinGW builds (which don't define _WINDOWS)
          PICOQUIC_H="${PICOQUIC_DIR}/picoquic/picoquic.h"
          if [ -f "$PICOQUIC_H" ]; then
            # Update the Windows check to also include MinGW defines
            sed -i 's/#ifdef _WINDOWS/#if defined(_WINDOWS) || defined(__WIN32__) || defined(__MINGW32__) || defined(_WIN32)/' "$PICOQUIC_H" || true
          fi
          
          # Patch other picoquic headers that include arpa/inet.h directly
          for header in "picoquic/picosocks.h"; do
            HEADER_FILE="${PICOQUIC_DIR}/${header}"
            if [ -f "$HEADER_FILE" ]; then
              # Create a temporary file with the replacement
              TMP_FILE=$(mktemp)
              awk '{
                if ($0 == "#include <arpa/inet.h>") {
                  print "#if defined(_WINDOWS) || defined(__WIN32__) || defined(__MINGW32__) || defined(_WIN32)"
                  print "#include <winsock2.h>"
                  print "#else"
                  print "#include <arpa/inet.h>"
                  print "#endif"
                } else {
                  print
                }
              }' "$HEADER_FILE" > "$TMP_FILE" && mv "$TMP_FILE" "$HEADER_FILE" || true
            fi
          done

      - name: Apply patches for Windows
        if: runner.os == 'Windows'
        working-directory: slipstream-rust
        shell: bash
        run: |
          # Patch build.rs directly with sed (more reliable than patch on Windows)
          BUILD_RS="crates/slipstream-ffi/build.rs"
          if [ -f "$BUILD_RS" ]; then
            echo "Patching $BUILD_RS for Windows..."
            
            # Create the replacement block for OpenSSL/pthread section
            # Find and replace the three println! lines with Windows-aware version
            sed -i 's/println!("cargo:rustc-link-lib=dylib=ssl");/let target = env::var("TARGET").unwrap_or_default();\n    let is_windows = target.contains("windows") || target.contains("pc-windows");\n\n    if is_windows {\n        if let Ok(openssl_lib_dir) = env::var("OPENSSL_LIB_DIR") {\n            println!("cargo:rustc-link-search=native={}", openssl_lib_dir);\n        }\n        println!("cargo:rustc-link-lib=dylib=libssl");\n        println!("cargo:rustc-link-lib=dylib=libcrypto");\n    } else {\n        println!("cargo:rustc-link-lib=dylib=ssl");\n        println!("cargo:rustc-link-lib=dylib=crypto");\n    }/' "$BUILD_RS"
            
            # Remove the now-duplicate crypto line
            sed -i '/println!("cargo:rustc-link-lib=dylib=crypto");/d' "$BUILD_RS"
            
            # Replace pthread with conditional ws2_32/pthread
            sed -i 's/println!("cargo:rustc-link-lib=dylib=pthread");/if is_windows {\n        println!("cargo:rustc-link-lib=dylib=ws2_32");\n    } else {\n        println!("cargo:rustc-link-lib=dylib=pthread");\n    }/' "$BUILD_RS"
            
            echo "Successfully patched $BUILD_RS"
          fi
          
          # Apply picoquic_utils.h patch
          PICOQUIC_UTILS_PATCH="${GITHUB_WORKSPACE}/patches/picoquic_utils.h.patch"
          if [ -f "$PICOQUIC_UTILS_PATCH" ]; then
            # Convert to Unix line endings and apply
            sed -i 's/\r$//' "$PICOQUIC_UTILS_PATCH"
            patch -p1 < "$PICOQUIC_UTILS_PATCH" || {
              echo "Warning: picoquic_utils.h patch application failed, trying with --merge"
              patch -p1 --merge < "$PICOQUIC_UTILS_PATCH" || {
                echo "Error: Failed to apply picoquic_utils.h patch"
                exit 1
              }
            }
          else
            echo "Warning: Patch file not found at $PICOQUIC_UTILS_PATCH"
          fi
          
          # Apply Cargo.toml patch (add winapi dependency)
          CARGO_PATCH="${GITHUB_WORKSPACE}/patches/Cargo.toml.patch"
          if [ -f "$CARGO_PATCH" ]; then
            sed -i 's/\r$//' "$CARGO_PATCH"
            patch -p1 < "$CARGO_PATCH" || {
              echo "Warning: Cargo.toml patch application failed, trying with --merge"
              patch -p1 --merge < "$CARGO_PATCH" || {
                echo "Error: Failed to apply Cargo.toml patch"
                exit 1
              }
            }
          fi
          
          # Patch runtime.rs and picoquic.rs for Windows socket types
          WINDOWS_PATCH_SCRIPT="${GITHUB_WORKSPACE}/patches/apply_windows_socket_patch.sh"
          if [ -f "$WINDOWS_PATCH_SCRIPT" ]; then
            bash "$WINDOWS_PATCH_SCRIPT"
          else
            echo "Warning: Windows socket patch script not found"
          fi

      - name: Build slipstream binaries
        working-directory: slipstream-rust
        shell: bash
        run: |
          if [[ "${{ matrix.target }}" == "aarch64-unknown-linux-gnu" ]] || [[ "${{ matrix.target }}" == "armv7-unknown-linux-gnueabihf" ]]; then
            export OPENSSL_STATIC=1
          fi
          
          # For macOS ARM64 (native build on ARM runner), set OpenSSL paths
          if [[ "${{ matrix.target }}" == "aarch64-apple-darwin" ]]; then
            export OPENSSL_LIB_DIR=/opt/homebrew/opt/openssl@3/lib
            export OPENSSL_INCLUDE_DIR=/opt/homebrew/opt/openssl@3/include
            export CARGO_TARGET_AARCH64_APPLE_DARWIN_RUSTFLAGS="-C link-arg=-L/opt/homebrew/opt/openssl@3/lib"
          fi
          
          cargo build --release --target ${{ matrix.target }} -p slipstream-client -p slipstream-server
        env:
          PICOQUIC_FETCH_PTLS: ON
          PICOQUIC_AUTO_BUILD: 1

      - name: Prepare binaries
        shell: bash
        run: |
          mkdir -p build_assets
          # Rename binaries to include platform info for easy identification
          cp "slipstream-rust/target/${{ matrix.target }}/release/slipstream-client${{ env.EXE_EXT }}" "build_assets/slipstream-client-${{ env.ASSET_NAME }}${{ env.EXE_EXT }}"
          cp "slipstream-rust/target/${{ matrix.target }}/release/slipstream-server${{ env.EXE_EXT }}" "build_assets/slipstream-server-${{ env.ASSET_NAME }}${{ env.EXE_EXT }}"
          if [ "${{ runner.os }}" != "Windows" ]; then chmod +x build_assets/*; fi

      - name: Upload client binary to release
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: build_assets/slipstream-client-${{ env.ASSET_NAME }}${{ env.EXE_EXT }}
          asset_name: slipstream-client-${{ env.ASSET_NAME }}${{ env.EXE_EXT }}
          tag: ${{ github.ref }}
          overwrite: true

      - name: Upload server binary to release
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: build_assets/slipstream-server-${{ env.ASSET_NAME }}${{ env.EXE_EXT }}
          asset_name: slipstream-server-${{ env.ASSET_NAME }}${{ env.EXE_EXT }}
          tag: ${{ github.ref }}
          overwrite: true

      - name: Upload client artifact
        uses: actions/upload-artifact@v4
        with:
          name: slipstream-client-${{ env.ASSET_NAME }}
          path: build_assets/slipstream-client-${{ env.ASSET_NAME }}${{ env.EXE_EXT }}
          retention-days: 7

      - name: Upload server artifact
        uses: actions/upload-artifact@v4
        with:
          name: slipstream-server-${{ env.ASSET_NAME }}
          path: build_assets/slipstream-server-${{ env.ASSET_NAME }}${{ env.EXE_EXT }}
          retention-days: 7
